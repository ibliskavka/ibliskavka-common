using System;
using System.Collections;
using System.Collections.Generic;
using System.Resources;

namespace Ibliskavka.Common.Command
{
    /// <summary>
    /// Executes a sequence of commands and undos them if one fails.
    /// </summary>
    public class CommandManager
    {
        //I dont want to deal with multiple executions or restarts at this point.
        private bool _hasExecuted = false;
        private const string ALREADY_EXECUTED_ERROR_MESSAGE = "This command manager has already been executed. Please create a new one.";

        private readonly Queue<ICommand> _notExecuted;
        private readonly Stack<ICommand> _executed;

        /// <summary>
        /// Stores any errors generated by command execution. Should be empty if successful.
        /// </summary>
        public List<string> ExecuteErrors { get; private set; }

        /// <summary>
        /// Stores any errors generated during command undo.
        /// </summary>
        public List<string> UndoErrors { get; private set; }

        /// <summary>
        /// Initialize the object
        /// </summary>
        public CommandManager()
        {
            _notExecuted = new Queue<ICommand>();
            _executed = new Stack<ICommand>();
            ExecuteErrors = new List<string>();
            UndoErrors = new List<string>();
        }
        
        /// <summary>
        /// Adds a command to the Queue
        /// </summary>
        /// <param name="command">implementation of ICommand interface</param>
        public void Add(ICommand command)
        {
            if (_hasExecuted)
            {
                throw new Exception(ALREADY_EXECUTED_ERROR_MESSAGE);
            }

            _notExecuted.Enqueue(command);
        }

        /// <summary>
        /// Execute each command and automatically roll back if any command fails. Each Command Manager can be executed only once.
        /// </summary>
        public void Execute()
        {
            if (_hasExecuted)
            {
                throw new Exception(ALREADY_EXECUTED_ERROR_MESSAGE);
            }

            _hasExecuted = true;

            while (_notExecuted.Count > 0)
            {
                var cmd = _notExecuted.Dequeue();

                if (!cmd.Execute())
                {
                    //Command execution failed. Begin rollback.
                    ExecuteErrors.Add(cmd.GetExecuteMessage());

                    _executed.Push(cmd);
                    while (_executed.Count > 0)
                    {
                        var undo = _executed.Pop();
                        if (!undo.Undo())
                        {
                            UndoErrors.Add(undo.GetUndoMessage());
                        }
                    }

                    //Don't process any more commands
                    return;
                }
                else
                {
                    _executed.Push(cmd);
                }
            }
        }
    }
}